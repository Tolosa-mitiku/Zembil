# Zembil Flutter Project - Cursor Rules

## Project Overview
Zembil is a Flutter e-commerce application using Clean Architecture with Domain-Driven Design (DDD), BLoC for state management, and Firebase for authentication.

## Architecture Pattern: Clean Architecture + DDD

### Layer Structure
```
lib/
├── core/                    # Shared utilities, constants, themes
├── features/               # Feature modules (vertical slicing)
│   └── [feature_name]/
│       ├── data/           # Data layer
│       │   ├── data_sources/   # Remote/Local data sources
│       │   ├── models/         # Data models (DTOs)
│       │   └── repository/     # Repository implementations
│       ├── domain/         # Domain layer (business logic)
│       │   ├── entity/         # Domain entities
│       │   ├── repository/     # Repository contracts (abstract)
│       │   └── usecase/        # Use cases (single responsibility)
│       └── presentation/   # Presentation layer
│           ├── bloc/           # BLoC state management
│           ├── pages/          # Screen widgets
│           ├── widgets/        # Feature-specific widgets
│           └── routes.dart     # Feature routes
├── injector.dart           # Dependency injection setup
├── routes.dart             # App-level routing
└── main.dart               # Entry point
```

## Coding Standards

### 1. File Naming Conventions
- Use `snake_case` for all Dart files
- BLoC files: `[feature]_bloc.dart`, `[feature]_event.dart`, `[feature]_state.dart`
- Use cases: `[action]_[noun].dart` (e.g., `get_product.dart`, `login_with_email.dart`)
- Models: Match entity name with `_model` suffix
- Data sources: `[feature]_data_source.dart` (abstract), `[feature]_remote_data_source.dart` (implementation)

### 2. Class Naming Conventions
- Entities: `[Name]` (e.g., `Product`, `AuthUser`)
- Models: `[Name]Model` (e.g., `ProductModel`, `AuthUserModel`)
- Repositories (abstract): `[Feature]Repository`
- Repositories (impl): `[Feature]RepositoryImpl`
- Use cases: `[ActionNoun]` in PascalCase (e.g., `GetProduct`, `LoginWithEmail`)
- BLoCs: `[Feature]Bloc`
- Events: `[Feature]Event` with subclasses like `[Action]Event`
- States: `[Feature]State` with subclasses like `[Feature]Initial`, `[Feature]Loading`, `[Feature]Loaded`, `[Feature]Error`

### 3. Dependency Injection (GetIt)
```dart
// Register in order: External → Data Sources → Repositories → Use Cases → BLoCs
// Use registerLazySingleton for most dependencies
// Use registerFactory for widgets that need new instances

// Example pattern:
locator.registerLazySingleton(() => SomeBloc(
  useCase1: locator(),
  useCase2: locator(),
));
```

### 4. BLoC Pattern Rules
```dart
// Events - Always extend Equatable
abstract class FeatureEvent extends Equatable {
  @override
  List<Object?> get props => [];
}

// States - Always extend Equatable, include props
abstract class FeatureState extends Equatable {
  @override
  List<Object?> get props => [];
}

// BLoC - Handle all events with on<Event>
class FeatureBloc extends Bloc<FeatureEvent, FeatureState> {
  final SomeUseCase useCase;
  
  FeatureBloc({required this.useCase}) : super(FeatureInitial()) {
    on<SomeEvent>(_onSomeEvent);
  }
  
  Future<void> _onSomeEvent(SomeEvent event, Emitter<FeatureState> emit) async {
    emit(FeatureLoading());
    final result = await useCase();
    result.fold(
      (failure) => emit(FeatureError(failure.message)),
      (data) => emit(FeatureLoaded(data)),
    );
  }
}
```

### 5. Use Case Pattern
```dart
// Single responsibility - one use case per action
class GetProduct {
  final ProductRepository repository;
  
  GetProduct(this.repository);
  
  // Use call() method for cleaner syntax: useCase() instead of useCase.execute()
  Future<Either<Failure, Product>> call(String id) async {
    return await repository.getProduct(id);
  }
}
```

### 6. Repository Pattern
```dart
// Domain layer - Abstract contract
abstract class FeatureRepository {
  Future<Either<Failure, Data>> getData();
}

// Data layer - Implementation
class FeatureRepositoryImpl implements FeatureRepository {
  final FeatureDataSource dataSource;
  
  FeatureRepositoryImpl(this.dataSource);
  
  @override
  Future<Either<Failure, Data>> getData() async {
    try {
      final result = await dataSource.getData();
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }
}
```

### 7. Entity and Model Pattern
```dart
// Domain Entity - Pure Dart class
class Product {
  final String id;
  final String title;
  final double price;
  
  Product({required this.id, required this.title, required this.price});
}

// Data Model - Extends Entity, adds serialization
class ProductModel extends Product {
  ProductModel({required super.id, required super.title, required super.price});
  
  factory ProductModel.fromJson(Map<String, dynamic> json) {
    return ProductModel(
      id: json['_id'] ?? json['id'],
      title: json['title'],
      price: (json['price'] as num).toDouble(),
    );
  }
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'price': price,
  };
}
```

### 8. Error Handling with Either (dartz)
```dart
// Always use Either<Failure, Success> for operations that can fail
// Left = Failure, Right = Success

// Failure classes in core/failures.dart
abstract class Failure {
  final String message;
  const Failure(this.message);
}

class ServerFailure extends Failure {
  const ServerFailure(super.message);
}

class NetworkFailure extends Failure {
  const NetworkFailure(super.message);
}
```

### 9. Routing with GoRouter
```dart
// Feature-specific routes
class FeatureRoutes {
  static List<RouteBase> routes = [
    GoRoute(
      path: '/feature',
      builder: (context, state) => const FeaturePage(),
    ),
    GoRoute(
      path: '/feature/:id',
      builder: (context, state) => FeatureDetailPage(
        id: state.pathParameters['id']!,
      ),
    ),
  ];
}

// Aggregate in main routes.dart
class AppRouter {
  static final GoRouter router = GoRouter(
    routes: [
      GoRoute(path: "/", builder: (context, state) => const Splash()),
      ...FeatureRoutes.routes,
    ],
  );
}
```

### 10. Widget Best Practices
```dart
// Prefer const constructors
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});
  
  @override
  Widget build(BuildContext context) {
    // Use context.read<Bloc>() for events
    // Use BlocBuilder/BlocConsumer for state
    return BlocBuilder<FeatureBloc, FeatureState>(
      builder: (context, state) {
        if (state is FeatureLoading) {
          return const CircularProgressIndicator();
        }
        if (state is FeatureLoaded) {
          return FeatureContent(data: state.data);
        }
        if (state is FeatureError) {
          return ErrorWidget(message: state.message);
        }
        return const SizedBox.shrink();
      },
    );
  }
}
```

## Firebase Integration

### Authentication
- Use `firebase_auth` for authentication
- Use `google_sign_in` for Google OAuth
- Store Firebase ID tokens in secure storage for API calls
- Verify email before allowing full access

### Push Notifications (to be implemented)
- Use `firebase_messaging` for FCM
- Store FCM tokens in user profile on backend
- Handle foreground/background/terminated states

## State Management Rules

### When to use which BLoC pattern:
- **BlocBuilder**: When only rebuilding UI based on state
- **BlocListener**: When performing side effects (navigation, snackbars)
- **BlocConsumer**: When needing both (rebuild UI + side effects)
- **BlocSelector**: When only listening to specific state properties

### BLoC Scope:
- Global BLoCs (Auth, Profile): Provided at app level in `main.dart`
- Feature BLoCs: Provided at feature/route level
- Page-specific BLoCs: Provided in the page itself

## Code Quality Checklist

### Before committing:
- [ ] All use cases have single responsibility
- [ ] BLoC events and states extend Equatable with proper props
- [ ] Error handling uses Either pattern
- [ ] No business logic in presentation layer
- [ ] Models properly serialize/deserialize
- [ ] Dependencies registered in correct order in injector.dart
- [ ] Widgets use const constructors where possible
- [ ] No hardcoded strings (use constants)
- [ ] Routes follow naming convention

## Common Patterns

### Loading States
```dart
// Always show loading indicator while fetching data
if (state is FeatureLoading) {
  return const Center(child: CircularProgressIndicator());
}
```

### Error Handling in UI
```dart
BlocListener<FeatureBloc, FeatureState>(
  listener: (context, state) {
    if (state is FeatureError) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(state.message)),
      );
    }
  },
  child: // ...
)
```

### Navigation after action
```dart
BlocListener<AuthBloc, AuthState>(
  listener: (context, state) {
    if (state is AuthAuthenticated) {
      context.go('/home');
    }
  },
  child: // ...
)
```

## Environment Variables
- Store sensitive keys in `.env` file
- Access via `flutter_dotenv`: `dotenv.env['KEY_NAME']`
- Never commit `.env` to version control

## Testing Guidelines
- Unit tests for use cases and repositories
- Widget tests for presentation layer
- Integration tests for critical flows
- Mock dependencies using `mocktail` or `mockito`

